{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * useWidget Hook\n * \n * Custom hook for widget lifecycle management and configuration.\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useSocket } from '../context/SocketContext';\nimport { useWidgets } from '../context/WidgetContext';\n/**\n * Custom hook for widget lifecycle management\n * \n * @param widgetId Widget ID\n * @param options Widget options\n * @returns Widget state and methods\n */\nexport const useWidget = (widgetId, options = {}) => {\n  _s();\n  const {\n    socket,\n    isConnected\n  } = useSocket();\n  const {\n    getWidgetConfig,\n    updateWidgetConfig\n  } = useWidgets();\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const initialized = useRef(false);\n\n  // Get config from context or use default\n  const savedConfig = getWidgetConfig(widgetId);\n  const [config, setConfig] = useState(savedConfig || options.defaultConfig || {});\n\n  // Initialize widget\n  useEffect(() => {\n    const init = async () => {\n      try {\n        setIsLoading(true);\n\n        // Call onInit handler if provided\n        if (options.onInit && !initialized.current) {\n          await options.onInit();\n          initialized.current = true;\n        }\n\n        // Request data from server if connected\n        if (socket && isConnected) {\n          socket.emit('widget:init', {\n            widgetId\n          });\n        }\n        setIsLoading(false);\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error(String(err)));\n        setIsLoading(false);\n      }\n    };\n    init();\n\n    // Cleanup on unmount\n    return () => {\n      if (options.onDestroy) {\n        options.onDestroy();\n      }\n    };\n  }, [widgetId, socket, isConnected]);\n\n  // Listen for config changes\n  useEffect(() => {\n    if (savedConfig && JSON.stringify(savedConfig) !== JSON.stringify(config)) {\n      setConfig(savedConfig);\n\n      // Call onConfigChange handler if provided\n      if (options.onConfigChange) {\n        options.onConfigChange(savedConfig);\n      }\n    }\n  }, [savedConfig]);\n\n  // Listen for data updates from server\n  useEffect(() => {\n    if (socket && isConnected) {\n      const handleDataUpdate = data => {\n        if (data.widgetId === widgetId) {\n          // Call onDataUpdate handler if provided\n          if (options.onDataUpdate) {\n            options.onDataUpdate(data.payload);\n          }\n        }\n      };\n      socket.on('widget:dataUpdate', handleDataUpdate);\n      return () => {\n        socket.off('widget:dataUpdate', handleDataUpdate);\n      };\n    }\n  }, [socket, isConnected, widgetId]);\n\n  // Update config\n  const updateConfig = useCallback(newConfig => {\n    const updatedConfig = {\n      ...config,\n      ...newConfig\n    };\n    setConfig(updatedConfig);\n    updateWidgetConfig(widgetId, updatedConfig);\n\n    // Call onConfigChange handler if provided\n    if (options.onConfigChange) {\n      options.onConfigChange(updatedConfig);\n    }\n  }, [widgetId, config, updateWidgetConfig]);\n\n  // Reset error\n  const resetError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  // Send event to server\n  const sendEvent = useCallback((eventType, payload) => {\n    if (socket && isConnected) {\n      socket.emit('widget:event', {\n        widgetId,\n        eventType,\n        payload\n      });\n    }\n  }, [socket, isConnected, widgetId]);\n  return {\n    config,\n    updateConfig,\n    isLoading,\n    error,\n    resetError,\n    sendEvent\n  };\n};\n_s(useWidget, \"TlMB2a7X+HchfxCJRzhScDN2mOs=\", false, function () {\n  return [useSocket, useWidgets];\n});\nexport default useWidget;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","useSocket","useWidgets","useWidget","widgetId","options","_s","socket","isConnected","getWidgetConfig","updateWidgetConfig","isLoading","setIsLoading","error","setError","initialized","savedConfig","config","setConfig","defaultConfig","init","onInit","current","emit","err","Error","String","onDestroy","JSON","stringify","onConfigChange","handleDataUpdate","data","onDataUpdate","payload","on","off","updateConfig","newConfig","updatedConfig","resetError","sendEvent","eventType"],"sources":["/mnt/network_repo/test_ai_rpg/RPGer/client/src/hooks/useWidget.ts"],"sourcesContent":["/**\n * useWidget Hook\n * \n * Custom hook for widget lifecycle management and configuration.\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useSocket } from '../context/SocketContext';\nimport { useWidgets } from '../context/WidgetContext';\nimport widgetRegistry from '../services/WidgetRegistry';\nimport { WidgetProps, WidgetConfig, WidgetEventType } from '../types/widget';\n\ninterface UseWidgetOptions {\n  defaultConfig?: WidgetConfig;\n  onInit?: () => void | Promise<void>;\n  onUpdate?: () => void | Promise<void>;\n  onDestroy?: () => void | Promise<void>;\n  onConfigChange?: (config: WidgetConfig) => void | Promise<void>;\n  onDataUpdate?: (data: any) => void | Promise<void>;\n}\n\ninterface UseWidgetResult {\n  config: WidgetConfig;\n  updateConfig: (newConfig: Partial<WidgetConfig>) => void;\n  isLoading: boolean;\n  error: Error | null;\n  resetError: () => void;\n  sendEvent: (eventType: string, payload?: any) => void;\n}\n\n/**\n * Custom hook for widget lifecycle management\n * \n * @param widgetId Widget ID\n * @param options Widget options\n * @returns Widget state and methods\n */\nexport const useWidget = (\n  widgetId: string,\n  options: UseWidgetOptions = {}\n): UseWidgetResult => {\n  const { socket, isConnected } = useSocket();\n  const { getWidgetConfig, updateWidgetConfig } = useWidgets();\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const initialized = useRef(false);\n  \n  // Get config from context or use default\n  const savedConfig = getWidgetConfig(widgetId);\n  const [config, setConfig] = useState<WidgetConfig>(\n    savedConfig || options.defaultConfig || {}\n  );\n  \n  // Initialize widget\n  useEffect(() => {\n    const init = async () => {\n      try {\n        setIsLoading(true);\n        \n        // Call onInit handler if provided\n        if (options.onInit && !initialized.current) {\n          await options.onInit();\n          initialized.current = true;\n        }\n        \n        // Request data from server if connected\n        if (socket && isConnected) {\n          socket.emit('widget:init', { widgetId });\n        }\n        \n        setIsLoading(false);\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error(String(err)));\n        setIsLoading(false);\n      }\n    };\n    \n    init();\n    \n    // Cleanup on unmount\n    return () => {\n      if (options.onDestroy) {\n        options.onDestroy();\n      }\n    };\n  }, [widgetId, socket, isConnected]);\n  \n  // Listen for config changes\n  useEffect(() => {\n    if (savedConfig && JSON.stringify(savedConfig) !== JSON.stringify(config)) {\n      setConfig(savedConfig);\n      \n      // Call onConfigChange handler if provided\n      if (options.onConfigChange) {\n        options.onConfigChange(savedConfig);\n      }\n    }\n  }, [savedConfig]);\n  \n  // Listen for data updates from server\n  useEffect(() => {\n    if (socket && isConnected) {\n      const handleDataUpdate = (data: any) => {\n        if (data.widgetId === widgetId) {\n          // Call onDataUpdate handler if provided\n          if (options.onDataUpdate) {\n            options.onDataUpdate(data.payload);\n          }\n        }\n      };\n      \n      socket.on('widget:dataUpdate', handleDataUpdate);\n      \n      return () => {\n        socket.off('widget:dataUpdate', handleDataUpdate);\n      };\n    }\n  }, [socket, isConnected, widgetId]);\n  \n  // Update config\n  const updateConfig = useCallback((newConfig: Partial<WidgetConfig>) => {\n    const updatedConfig = {\n      ...config,\n      ...newConfig\n    };\n    \n    setConfig(updatedConfig);\n    updateWidgetConfig(widgetId, updatedConfig);\n    \n    // Call onConfigChange handler if provided\n    if (options.onConfigChange) {\n      options.onConfigChange(updatedConfig);\n    }\n  }, [widgetId, config, updateWidgetConfig]);\n  \n  // Reset error\n  const resetError = useCallback(() => {\n    setError(null);\n  }, []);\n  \n  // Send event to server\n  const sendEvent = useCallback((eventType: string, payload?: any) => {\n    if (socket && isConnected) {\n      socket.emit('widget:event', {\n        widgetId,\n        eventType,\n        payload\n      });\n    }\n  }, [socket, isConnected, widgetId]);\n  \n  return {\n    config,\n    updateConfig,\n    isLoading,\n    error,\n    resetError,\n    sendEvent\n  };\n};\n\nexport default useWidget;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}