{"ast":null,"code":"/**\n * Widget Registry Service\n * \n * Manages the registration and retrieval of widgets in the application.\n */\n\nimport { WidgetEventType } from '../types/widget';\nclass WidgetRegistry {\n  constructor() {\n    this.widgets = new Map();\n    this.eventHandlers = new Map();\n  }\n  /**\n   * Register a widget with the registry\n   * \n   * @param registration Widget registration information\n   * @returns boolean indicating success\n   */\n  registerWidget(registration) {\n    if (this.widgets.has(registration.metadata.id)) {\n      console.warn(`Widget with ID ${registration.metadata.id} is already registered.`);\n      return false;\n    }\n    this.widgets.set(registration.metadata.id, registration);\n\n    // Emit widget registered event\n    this.emitEvent({\n      type: WidgetEventType.INIT,\n      widgetId: registration.metadata.id\n    });\n    return true;\n  }\n\n  /**\n   * Unregister a widget from the registry\n   * \n   * @param widgetId Widget ID to unregister\n   * @returns boolean indicating success\n   */\n  unregisterWidget(widgetId) {\n    if (!this.widgets.has(widgetId)) {\n      console.warn(`Widget with ID ${widgetId} is not registered.`);\n      return false;\n    }\n\n    // Emit widget unregistered event\n    this.emitEvent({\n      type: WidgetEventType.DESTROY,\n      widgetId\n    });\n    return this.widgets.delete(widgetId);\n  }\n\n  /**\n   * Get a widget by ID\n   * \n   * @param widgetId Widget ID\n   * @returns Widget registration or undefined if not found\n   */\n  getWidget(widgetId) {\n    return this.widgets.get(widgetId);\n  }\n\n  /**\n   * Get all registered widgets\n   * \n   * @returns Array of widget registrations\n   */\n  getAllWidgets() {\n    return Array.from(this.widgets.values());\n  }\n\n  /**\n   * Get widgets by category\n   * \n   * @param category Widget category\n   * @returns Array of widget registrations in the specified category\n   */\n  getWidgetsByCategory(category) {\n    return this.getAllWidgets().filter(widget => widget.metadata.category === category);\n  }\n\n  /**\n   * Update widget configuration\n   * \n   * @param widgetId Widget ID\n   * @param config New configuration\n   * @returns boolean indicating success\n   */\n  updateWidgetConfig(widgetId, config) {\n    const widget = this.widgets.get(widgetId);\n    if (!widget) {\n      console.warn(`Widget with ID ${widgetId} is not registered.`);\n      return false;\n    }\n\n    // Emit config change event\n    this.emitEvent({\n      type: WidgetEventType.CONFIG_CHANGE,\n      widgetId,\n      payload: config\n    });\n    return true;\n  }\n\n  /**\n   * Register an event handler\n   * \n   * @param eventType Event type to listen for\n   * @param handler Event handler function\n   */\n  addEventListener(eventType, handler) {\n    var _this$eventHandlers$g;\n    const eventKey = eventType.toString();\n    if (!this.eventHandlers.has(eventKey)) {\n      this.eventHandlers.set(eventKey, new Set());\n    }\n    (_this$eventHandlers$g = this.eventHandlers.get(eventKey)) === null || _this$eventHandlers$g === void 0 ? void 0 : _this$eventHandlers$g.add(handler);\n  }\n\n  /**\n   * Remove an event handler\n   * \n   * @param eventType Event type\n   * @param handler Event handler function to remove\n   * @returns boolean indicating success\n   */\n  removeEventListener(eventType, handler) {\n    const eventKey = eventType.toString();\n    const handlers = this.eventHandlers.get(eventKey);\n    if (!handlers) {\n      return false;\n    }\n    return handlers.delete(handler);\n  }\n\n  /**\n   * Emit a widget event\n   * \n   * @param event Widget event to emit\n   */\n  emitEvent(event) {\n    const eventKey = event.type.toString();\n    const handlers = this.eventHandlers.get(eventKey);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(event);\n        } catch (error) {\n          console.error(`Error in widget event handler for ${event.type}:`, error);\n        }\n      });\n    }\n  }\n}\n\n// Create singleton instance\nconst widgetRegistry = new WidgetRegistry();\nexport default widgetRegistry;","map":{"version":3,"names":["WidgetEventType","WidgetRegistry","constructor","widgets","Map","eventHandlers","registerWidget","registration","has","metadata","id","console","warn","set","emitEvent","type","INIT","widgetId","unregisterWidget","DESTROY","delete","getWidget","get","getAllWidgets","Array","from","values","getWidgetsByCategory","category","filter","widget","updateWidgetConfig","config","CONFIG_CHANGE","payload","addEventListener","eventType","handler","_this$eventHandlers$g","eventKey","toString","Set","add","removeEventListener","handlers","event","forEach","error","widgetRegistry"],"sources":["/mnt/network_repo/test_ai_rpg/RPGer/client/src/services/WidgetRegistry.ts"],"sourcesContent":["/**\n * Widget Registry Service\n * \n * Manages the registration and retrieval of widgets in the application.\n */\n\nimport { \n  WidgetRegistration, \n  WidgetMetadata, \n  WidgetComponent,\n  WidgetCategory,\n  WidgetEventType,\n  WidgetEvent,\n  WidgetEventHandler,\n  WidgetConfig\n} from '../types/widget';\n\nclass WidgetRegistry {\n  private widgets: Map<string, WidgetRegistration> = new Map();\n  private eventHandlers: Map<string, Set<WidgetEventHandler>> = new Map();\n  \n  /**\n   * Register a widget with the registry\n   * \n   * @param registration Widget registration information\n   * @returns boolean indicating success\n   */\n  public registerWidget(registration: WidgetRegistration): boolean {\n    if (this.widgets.has(registration.metadata.id)) {\n      console.warn(`Widget with ID ${registration.metadata.id} is already registered.`);\n      return false;\n    }\n    \n    this.widgets.set(registration.metadata.id, registration);\n    \n    // Emit widget registered event\n    this.emitEvent({\n      type: WidgetEventType.INIT,\n      widgetId: registration.metadata.id\n    });\n    \n    return true;\n  }\n  \n  /**\n   * Unregister a widget from the registry\n   * \n   * @param widgetId Widget ID to unregister\n   * @returns boolean indicating success\n   */\n  public unregisterWidget(widgetId: string): boolean {\n    if (!this.widgets.has(widgetId)) {\n      console.warn(`Widget with ID ${widgetId} is not registered.`);\n      return false;\n    }\n    \n    // Emit widget unregistered event\n    this.emitEvent({\n      type: WidgetEventType.DESTROY,\n      widgetId\n    });\n    \n    return this.widgets.delete(widgetId);\n  }\n  \n  /**\n   * Get a widget by ID\n   * \n   * @param widgetId Widget ID\n   * @returns Widget registration or undefined if not found\n   */\n  public getWidget(widgetId: string): WidgetRegistration | undefined {\n    return this.widgets.get(widgetId);\n  }\n  \n  /**\n   * Get all registered widgets\n   * \n   * @returns Array of widget registrations\n   */\n  public getAllWidgets(): WidgetRegistration[] {\n    return Array.from(this.widgets.values());\n  }\n  \n  /**\n   * Get widgets by category\n   * \n   * @param category Widget category\n   * @returns Array of widget registrations in the specified category\n   */\n  public getWidgetsByCategory(category: WidgetCategory): WidgetRegistration[] {\n    return this.getAllWidgets().filter(\n      widget => widget.metadata.category === category\n    );\n  }\n  \n  /**\n   * Update widget configuration\n   * \n   * @param widgetId Widget ID\n   * @param config New configuration\n   * @returns boolean indicating success\n   */\n  public updateWidgetConfig(widgetId: string, config: WidgetConfig): boolean {\n    const widget = this.widgets.get(widgetId);\n    \n    if (!widget) {\n      console.warn(`Widget with ID ${widgetId} is not registered.`);\n      return false;\n    }\n    \n    // Emit config change event\n    this.emitEvent({\n      type: WidgetEventType.CONFIG_CHANGE,\n      widgetId,\n      payload: config\n    });\n    \n    return true;\n  }\n  \n  /**\n   * Register an event handler\n   * \n   * @param eventType Event type to listen for\n   * @param handler Event handler function\n   */\n  public addEventListener(eventType: WidgetEventType, handler: WidgetEventHandler): void {\n    const eventKey = eventType.toString();\n    \n    if (!this.eventHandlers.has(eventKey)) {\n      this.eventHandlers.set(eventKey, new Set());\n    }\n    \n    this.eventHandlers.get(eventKey)?.add(handler);\n  }\n  \n  /**\n   * Remove an event handler\n   * \n   * @param eventType Event type\n   * @param handler Event handler function to remove\n   * @returns boolean indicating success\n   */\n  public removeEventListener(eventType: WidgetEventType, handler: WidgetEventHandler): boolean {\n    const eventKey = eventType.toString();\n    const handlers = this.eventHandlers.get(eventKey);\n    \n    if (!handlers) {\n      return false;\n    }\n    \n    return handlers.delete(handler);\n  }\n  \n  /**\n   * Emit a widget event\n   * \n   * @param event Widget event to emit\n   */\n  public emitEvent(event: WidgetEvent): void {\n    const eventKey = event.type.toString();\n    const handlers = this.eventHandlers.get(eventKey);\n    \n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(event);\n        } catch (error) {\n          console.error(`Error in widget event handler for ${event.type}:`, error);\n        }\n      });\n    }\n  }\n}\n\n// Create singleton instance\nconst widgetRegistry = new WidgetRegistry();\n\nexport default widgetRegistry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}