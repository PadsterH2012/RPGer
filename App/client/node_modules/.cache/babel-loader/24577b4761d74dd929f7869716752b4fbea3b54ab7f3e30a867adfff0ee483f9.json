{"ast":null,"code":"var _jsxFileName = \"/mnt/network_repo/test_ai_rpg/RPGer/client/src/context/WidgetContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n/**\n * Widget Context\n * \n * Provides widget-related functionality throughout the application.\n */\n\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { useSocket } from './SocketContext';\nimport widgetRegistry from '../services/WidgetRegistry';\nimport { WidgetEventType } from '../types/widget';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WidgetContext = /*#__PURE__*/createContext({\n  widgets: [],\n  activeWidgets: [],\n  addWidget: () => {},\n  removeWidget: () => {},\n  updateWidgetConfig: () => {},\n  getWidgetConfig: () => undefined,\n  isWidgetActive: () => false\n});\nexport const WidgetProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    socket,\n    isConnected\n  } = useSocket();\n  const [widgets, setWidgets] = useState([]);\n  const [activeWidgets, setActiveWidgets] = useState([]);\n  const [widgetConfigs, setWidgetConfigs] = useState({});\n\n  // Load widgets from registry\n  useEffect(() => {\n    const updateWidgets = () => {\n      setWidgets(widgetRegistry.getAllWidgets());\n    };\n\n    // Initial load\n    updateWidgets();\n\n    // Listen for widget registry changes\n    const handleWidgetInit = event => {\n      updateWidgets();\n    };\n    const handleWidgetDestroy = event => {\n      updateWidgets();\n      // Remove from active widgets if present\n      setActiveWidgets(prev => prev.filter(id => id !== event.widgetId));\n    };\n    widgetRegistry.addEventListener(WidgetEventType.INIT, handleWidgetInit);\n    widgetRegistry.addEventListener(WidgetEventType.DESTROY, handleWidgetDestroy);\n    return () => {\n      widgetRegistry.removeEventListener(WidgetEventType.INIT, handleWidgetInit);\n      widgetRegistry.removeEventListener(WidgetEventType.DESTROY, handleWidgetDestroy);\n    };\n  }, []);\n\n  // Load active widgets and configs from localStorage\n  useEffect(() => {\n    try {\n      const savedActiveWidgets = localStorage.getItem('activeWidgets');\n      if (savedActiveWidgets) {\n        setActiveWidgets(JSON.parse(savedActiveWidgets));\n      }\n      const savedWidgetConfigs = localStorage.getItem('widgetConfigs');\n      if (savedWidgetConfigs) {\n        setWidgetConfigs(JSON.parse(savedWidgetConfigs));\n      }\n    } catch (error) {\n      console.error('Error loading widget data from localStorage:', error);\n    }\n  }, []);\n\n  // Save active widgets and configs to localStorage when they change\n  useEffect(() => {\n    try {\n      localStorage.setItem('activeWidgets', JSON.stringify(activeWidgets));\n    } catch (error) {\n      console.error('Error saving active widgets to localStorage:', error);\n    }\n  }, [activeWidgets]);\n  useEffect(() => {\n    try {\n      localStorage.setItem('widgetConfigs', JSON.stringify(widgetConfigs));\n    } catch (error) {\n      console.error('Error saving widget configs to localStorage:', error);\n    }\n  }, [widgetConfigs]);\n\n  // Socket.IO integration for widget sync\n  useEffect(() => {\n    if (socket && isConnected) {\n      // Listen for widget updates from server\n      socket.on('widgets:update', data => {\n        if (data.activeWidgets) {\n          setActiveWidgets(data.activeWidgets);\n        }\n        if (data.configs) {\n          setWidgetConfigs(prev => ({\n            ...prev,\n            ...data.configs\n          }));\n        }\n      });\n\n      // Send current widget state to server\n      socket.emit('widgets:sync', {\n        activeWidgets,\n        configs: widgetConfigs\n      });\n      return () => {\n        socket.off('widgets:update');\n      };\n    }\n  }, [socket, isConnected, activeWidgets, widgetConfigs]);\n  const addWidget = (widgetId, initialConfig) => {\n    if (!activeWidgets.includes(widgetId)) {\n      setActiveWidgets(prev => [...prev, widgetId]);\n      if (initialConfig) {\n        setWidgetConfigs(prev => ({\n          ...prev,\n          [widgetId]: initialConfig\n        }));\n      }\n\n      // Sync with server\n      if (socket && isConnected) {\n        socket.emit('widgets:add', {\n          widgetId,\n          config: initialConfig\n        });\n      }\n    }\n  };\n  const removeWidget = widgetId => {\n    setActiveWidgets(prev => prev.filter(id => id !== widgetId));\n\n    // Sync with server\n    if (socket && isConnected) {\n      socket.emit('widgets:remove', {\n        widgetId\n      });\n    }\n  };\n  const updateWidgetConfig = (widgetId, config) => {\n    setWidgetConfigs(prev => ({\n      ...prev,\n      [widgetId]: {\n        ...prev[widgetId],\n        ...config\n      }\n    }));\n\n    // Update in registry\n    widgetRegistry.updateWidgetConfig(widgetId, config);\n\n    // Sync with server\n    if (socket && isConnected) {\n      socket.emit('widgets:updateConfig', {\n        widgetId,\n        config\n      });\n    }\n  };\n  const getWidgetConfig = widgetId => {\n    return widgetConfigs[widgetId];\n  };\n  const isWidgetActive = widgetId => {\n    return activeWidgets.includes(widgetId);\n  };\n  return /*#__PURE__*/_jsxDEV(WidgetContext.Provider, {\n    value: {\n      widgets,\n      activeWidgets,\n      addWidget,\n      removeWidget,\n      updateWidgetConfig,\n      getWidgetConfig,\n      isWidgetActive\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 202,\n    columnNumber: 5\n  }, this);\n};\n_s(WidgetProvider, \"22iBsvXQxD0Fy6z9MRdGJ1pewqg=\", false, function () {\n  return [useSocket];\n});\n_c = WidgetProvider;\nexport const useWidgets = () => {\n  _s2();\n  return useContext(WidgetContext);\n};\n_s2(useWidgets, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"WidgetProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useSocket","widgetRegistry","WidgetEventType","jsxDEV","_jsxDEV","WidgetContext","widgets","activeWidgets","addWidget","removeWidget","updateWidgetConfig","getWidgetConfig","undefined","isWidgetActive","WidgetProvider","children","_s","socket","isConnected","setWidgets","setActiveWidgets","widgetConfigs","setWidgetConfigs","updateWidgets","getAllWidgets","handleWidgetInit","event","handleWidgetDestroy","prev","filter","id","widgetId","addEventListener","INIT","DESTROY","removeEventListener","savedActiveWidgets","localStorage","getItem","JSON","parse","savedWidgetConfigs","error","console","setItem","stringify","on","data","configs","emit","off","initialConfig","includes","config","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWidgets","_s2","$RefreshReg$"],"sources":["/mnt/network_repo/test_ai_rpg/RPGer/client/src/context/WidgetContext.tsx"],"sourcesContent":["/**\n * Widget Context\n * \n * Provides widget-related functionality throughout the application.\n */\n\nimport React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { useSocket } from './SocketContext';\nimport widgetRegistry from '../services/WidgetRegistry';\nimport { \n  WidgetRegistration, \n  WidgetMetadata, \n  WidgetEventType, \n  WidgetEvent,\n  WidgetConfig\n} from '../types/widget';\n\ninterface WidgetContextProps {\n  widgets: WidgetRegistration[];\n  activeWidgets: string[];\n  addWidget: (widgetId: string, initialConfig?: WidgetConfig) => void;\n  removeWidget: (widgetId: string) => void;\n  updateWidgetConfig: (widgetId: string, config: WidgetConfig) => void;\n  getWidgetConfig: (widgetId: string) => WidgetConfig | undefined;\n  isWidgetActive: (widgetId: string) => boolean;\n}\n\nconst WidgetContext = createContext<WidgetContextProps>({\n  widgets: [],\n  activeWidgets: [],\n  addWidget: () => {},\n  removeWidget: () => {},\n  updateWidgetConfig: () => {},\n  getWidgetConfig: () => undefined,\n  isWidgetActive: () => false,\n});\n\ninterface WidgetProviderProps {\n  children: ReactNode;\n}\n\nexport const WidgetProvider: React.FC<WidgetProviderProps> = ({ children }) => {\n  const { socket, isConnected } = useSocket();\n  const [widgets, setWidgets] = useState<WidgetRegistration[]>([]);\n  const [activeWidgets, setActiveWidgets] = useState<string[]>([]);\n  const [widgetConfigs, setWidgetConfigs] = useState<Record<string, WidgetConfig>>({});\n  \n  // Load widgets from registry\n  useEffect(() => {\n    const updateWidgets = () => {\n      setWidgets(widgetRegistry.getAllWidgets());\n    };\n    \n    // Initial load\n    updateWidgets();\n    \n    // Listen for widget registry changes\n    const handleWidgetInit = (event: WidgetEvent) => {\n      updateWidgets();\n    };\n    \n    const handleWidgetDestroy = (event: WidgetEvent) => {\n      updateWidgets();\n      // Remove from active widgets if present\n      setActiveWidgets(prev => prev.filter(id => id !== event.widgetId));\n    };\n    \n    widgetRegistry.addEventListener(WidgetEventType.INIT, handleWidgetInit);\n    widgetRegistry.addEventListener(WidgetEventType.DESTROY, handleWidgetDestroy);\n    \n    return () => {\n      widgetRegistry.removeEventListener(WidgetEventType.INIT, handleWidgetInit);\n      widgetRegistry.removeEventListener(WidgetEventType.DESTROY, handleWidgetDestroy);\n    };\n  }, []);\n  \n  // Load active widgets and configs from localStorage\n  useEffect(() => {\n    try {\n      const savedActiveWidgets = localStorage.getItem('activeWidgets');\n      if (savedActiveWidgets) {\n        setActiveWidgets(JSON.parse(savedActiveWidgets));\n      }\n      \n      const savedWidgetConfigs = localStorage.getItem('widgetConfigs');\n      if (savedWidgetConfigs) {\n        setWidgetConfigs(JSON.parse(savedWidgetConfigs));\n      }\n    } catch (error) {\n      console.error('Error loading widget data from localStorage:', error);\n    }\n  }, []);\n  \n  // Save active widgets and configs to localStorage when they change\n  useEffect(() => {\n    try {\n      localStorage.setItem('activeWidgets', JSON.stringify(activeWidgets));\n    } catch (error) {\n      console.error('Error saving active widgets to localStorage:', error);\n    }\n  }, [activeWidgets]);\n  \n  useEffect(() => {\n    try {\n      localStorage.setItem('widgetConfigs', JSON.stringify(widgetConfigs));\n    } catch (error) {\n      console.error('Error saving widget configs to localStorage:', error);\n    }\n  }, [widgetConfigs]);\n  \n  // Socket.IO integration for widget sync\n  useEffect(() => {\n    if (socket && isConnected) {\n      // Listen for widget updates from server\n      socket.on('widgets:update', (data: { activeWidgets: string[], configs: Record<string, WidgetConfig> }) => {\n        if (data.activeWidgets) {\n          setActiveWidgets(data.activeWidgets);\n        }\n        \n        if (data.configs) {\n          setWidgetConfigs(prev => ({\n            ...prev,\n            ...data.configs\n          }));\n        }\n      });\n      \n      // Send current widget state to server\n      socket.emit('widgets:sync', {\n        activeWidgets,\n        configs: widgetConfigs\n      });\n      \n      return () => {\n        socket.off('widgets:update');\n      };\n    }\n  }, [socket, isConnected, activeWidgets, widgetConfigs]);\n  \n  const addWidget = (widgetId: string, initialConfig?: WidgetConfig) => {\n    if (!activeWidgets.includes(widgetId)) {\n      setActiveWidgets(prev => [...prev, widgetId]);\n      \n      if (initialConfig) {\n        setWidgetConfigs(prev => ({\n          ...prev,\n          [widgetId]: initialConfig\n        }));\n      }\n      \n      // Sync with server\n      if (socket && isConnected) {\n        socket.emit('widgets:add', {\n          widgetId,\n          config: initialConfig\n        });\n      }\n    }\n  };\n  \n  const removeWidget = (widgetId: string) => {\n    setActiveWidgets(prev => prev.filter(id => id !== widgetId));\n    \n    // Sync with server\n    if (socket && isConnected) {\n      socket.emit('widgets:remove', {\n        widgetId\n      });\n    }\n  };\n  \n  const updateWidgetConfig = (widgetId: string, config: WidgetConfig) => {\n    setWidgetConfigs(prev => ({\n      ...prev,\n      [widgetId]: {\n        ...prev[widgetId],\n        ...config\n      }\n    }));\n    \n    // Update in registry\n    widgetRegistry.updateWidgetConfig(widgetId, config);\n    \n    // Sync with server\n    if (socket && isConnected) {\n      socket.emit('widgets:updateConfig', {\n        widgetId,\n        config\n      });\n    }\n  };\n  \n  const getWidgetConfig = (widgetId: string): WidgetConfig | undefined => {\n    return widgetConfigs[widgetId];\n  };\n  \n  const isWidgetActive = (widgetId: string): boolean => {\n    return activeWidgets.includes(widgetId);\n  };\n  \n  return (\n    <WidgetContext.Provider\n      value={{\n        widgets,\n        activeWidgets,\n        addWidget,\n        removeWidget,\n        updateWidgetConfig,\n        getWidgetConfig,\n        isWidgetActive\n      }}\n    >\n      {children}\n    </WidgetContext.Provider>\n  );\n};\n\nexport const useWidgets = () => useContext(WidgetContext);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}